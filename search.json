{
	"pages": [
		{"title": "Hello Haskell", "text": "A Gentle Introduction to Haskell for CSC Members\n\nWhat is this for?\nHaskell - functional, pure and notorious. It is so beautiful, so complex, so intriguing, and yet so hard to learn.\nHopefully, this set of slides can take you through the process of learning haskell, and hence introduce you to the wonderful world of functional programming.\nSo what is haskell?\nThis should have been covered in the lesson slides. In case you are some outsider - don&#39;t be lazy. Go google.\nWhy should I learn haskell?\nTo get your brain fried. Seriously, if you are looking for some mental stimulation and break from the boring, tedious world of normal programming, then haskell is for you.\nOther frequently asked questions\n\nWhat if I don&#39;t understand x? where x = monad, functors, monoid etc\n\nIt is normal. Try doing the exercises, and if you really cannot do them, read through the slides again. If you still cannot understand it, don&#39;t think about it for a week and come back a while later.\n\nWhy do you use this site for the slides instead of, say, Google Presentation?\n\nBecause it is annoying to write code in Google Presentation. Also, powerpoint does not really work for this. Trust me.\nMore questions coming up...\n", "tags": "", "url": "index.html"},
		{"title": "Lesson 1 Introduction", "text": "Lesson 1: Introduction To Haskell\nBrought to you by your beloved (ex)-teaching head.\nTable of Content:\n\nvariables\ntypes\noperations\nfunctions\npairs\nlists\n\nVariables\nRemember in python, this is what happens...\nx = 3\nx = 4\nx = &quot;I don&#39;t care what you do here.&quot;\n\nBut haskell is pure!!!\nPurity\nIn haskell, variables are merely &#39;nicknames&#39; of values. Furthermore, you can&#39;t just give the nickname to someone else. In other words, there cannot be any &#39;side effects&#39; to anything you do.\nx :: Int\nx = 3\nx = 4 -- Error! Redefinition\n\nIn other words, the = sign in haskell works like your mathematical definition - once it is defined, you cannot change it.\nTypes\nIn python, we have int, str, and char data types. It is the same in haskell, except that there are more and they appear in different names\nInt\nThe type Int is like the python data type int, since they both hold integer values. The difference that the python int can hold up to some pretty large values, while this is not the case for haskell. In haskell, Int only stores machine sized integers. That is, somewhere near \\(\\pm 2^{63} \\) depending on your machine. To find the exact size, you can do this:\nbiggestInt, smallestInt :: Int\nbiggestInt  = maxBound\nsmallestInt = minBound\n\nDouble\nThere is nothing to interesting about Double. It is just like the python float.\nd1, d2 :: Double\nd1 = 3.14159\nd2 = 6.02e23 -- yes, you can use scientific notation\n\nChar\nA Char data type holds a unicode character\nc1, c2 :: Char\nc1 = &#39;x&#39;\nc2 = &#39;Ã˜&#39; -- Yes, non ascii also!!\n\nNote that a Char value must be surrounded with a pair of single quotes.\nBool\nA Bool data type holds a boolean value(True or False)\nb1, b2 :: Bool\nb1 = True\nb2 = False -- Just your plain old stuff\n\nString\nStrings are just list of characters(we will cover lists later)\ns :: String\ns = &quot;Hello, Haskell!&quot;\n\nNote that a String values must be surrounded by a pair of double quotes.\nOperations\nBut what can we do on these data types?\nArithmetics\nYou can perform your beloved arithmetics with Int, Integer and Double.\nex01 = 3 + 2\nex02 = 19 - 27\nex03 = 2.35 * 8.6\nex04 = 8.7 / 3.1\nex05 = mod 19 3\nex06 = 19 `mod` 3\nex07 = 7 ^ 222\nex08 = (-3) * (-7)\n\nNotice something in ex06? The function mod is called with the backticks. This is what we call the infix notation. In general, f a b is equivalent to this expression:  a &#96;f&#96; b\nArithmetics\nBut what if you tried this?\nbadArith1 = 1 + 0.1\nbadArith2 = 1 / 1\n\nIt turns out that both will result in a syntax error. This is because of the fact that the arithmetic operators can only operate on values of the same time, but you are trying to add a Int to a Double. The second one will also cause an error because you are trying two / two Ints, while / is only defined for Double. To perform Int division, you can do this: a &#96;div&#96; b.\nLogic\nNothing is ever complete with the good old logical operators. In haskell, you can manipulate boolean values in the following way:\nex11 = True &amp;&amp; False -- &amp;&amp; means &#39;and&#39;\nex12 = not (False || True) -- || means &#39;or&#39;\n\nNote that you do not have to put the backticks around and because it is defined to be an infix operator. We will cover more on that later. Of course, you can do other things that gives you a boolean result:\nex13 = (&#39;a&#39; == &#39;a&#39;) -- (==) tests for equality\nex14 = (16 /= 3) -- (/=) tests for inequality\nex15 = (5 &gt; 3) &amp;&amp; (&#39;p&#39; &lt;= &#39;q&#39;)\nex16 = &quot;Haskell&quot; &gt; &quot;C++&quot;\n\nYou can also do if statements, though it is not very recommended:\nex17 = if &quot;Haskell&quot; &gt; &quot;C++&quot; then &quot;Hooray&quot; else &quot;Nooooo&quot;\n-- basically: if &lt;cond&gt; then &lt;expr1&gt; else &lt;expr2&gt;\n\nFunctions!!!\nHaskell is FUNCTIONal, so function does play a big part in the language.\nA Tiny Peek\nHere is a very simple function that computes the factorial of an integer:\nfactorial :: Integer -&gt; Integer\nfactorial 0 = 1\nfactorial n = n * factorial (n - 1)\n\nThis may not make sense to you yet, so let&#39;s look at it carefully. The first line says that the function maps an Integer to another Integer. The second line says if the input is a 0, the return value if 1. The last line says for any other integers, the return value is the integer n multiplied by the factorial of n - 1.\nFor one thing, that looks like math!!!\nWell, yes, that&#39;s true.\nHaskell functions are indeed like mathematical functions in the sense that they just map one value to another, and we can define them recursively like what I&#39;ve done above. Besides specifying different rules for different values, we can also use a guard:\nhailstone :: Integer -&gt; Integer\nhailstone n\n  | n `mod` 2 == 0  -&gt; n `div` 2\n  | otherwise       -&gt; 3 * n + 1\n\nThis looks like the piecewise function mentioned in the H2 Math tutorial. Remember?\nWhat&#39;s that weird line?\nIn the previous examples, we always write something like function1 :: a -&gt; b before the actual definition of the function. This is the type of functions, which specify what types it accepts as input, and what type its output is.\nThere&#39;s more...\nWhat if you want more than one argument to the function? Of course you can pass in a pair, or a triplet, but here is an easier way:\nsumThree :: Integer -&gt; Integer -&gt; Integer -&gt; Integer\nsumThree x y z = x + y + z\n\nwhich basically says the function takes in three Integers and return another one. For now, just remember that the type signature goes like:\nfunction1 :: t1 -&gt; t2 -&gt; t3 -&gt; ... -&gt; tn -&gt; tr\n\nwhere $(t_1)$ to $(t_n)$ are types of the inputs, and $(t_r)$ is the type of the output.\nPairs\na.k.a. ships, or couples\nHow they work\nWe can pair two values up using the pair constructor. It looks something like:\np :: (Int, Char)\np = (3, &#39;x&#39;)\n\nYou know what&#39;s better? Its value can be extracted using pattern matching:\nsumPair :: (Int,Int) -&gt; Int\nsumPair (x,y) = x + y\n\nLists\nThe standard stuff\nExamples\nnums, range, range2 :: [Integer]\nnums   = [1,2,3,19]\nrange  = [1..100]\nrange2 = [2,4..100]\n\nHaskell (like Python) also has list comprehensions; you can read about them here\nStrings\nStrings are just lists of characters!!!\n-- hello1 and hello2 are exactly the same.\n\nhello1 :: [Char]\nhello1 = [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]\n\nhello2 :: String\nhello2 = &quot;hello&quot;\n\nhelloSame = hello1 == hello2 -- True\n\nConstructing Lists\nThe simplest list is the empty list:\nemptyList = []\n\nOther lists are built up from the empty list using the cons operator, (:). Cons takes an element and a list, and produces a new list with the element prepended to the front.\nex18 = 1 : []\nex19 = 3 : (1 : [])\nex20 = 2 : 3 : 4 : []\nex21 = [2,3,4] == 2 : 3 : 4 : []\n\nFunctions on Lists\nWe can apply pattern matching on lists too!\n-- Compute the length of a list of Integers.\nintListLength :: [Integer] -&gt; Integer\nintListLength []     = 0\nintListLength (x:xs) = 1 + intListLength xs\n\nThe first part says that the length of an empty list is zero. The second part says that if the input list looks like (x:xs), that is, a first element x consed onto a remaining list xs, then the length is one more than the length of xs.\nThat&#39;s it for now\nTake your time to absorb :3\n", "tags": "", "url": "lesson1.html"}
	]
}
